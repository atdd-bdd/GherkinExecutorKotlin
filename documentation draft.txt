
package gherkinexecutor.Feature_Examples
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class Feature_Examples{

    @Test
    fun test_Scenario_Filter_Data(){
        val feature_Examples_glue_object = Feature_Examples_glue()
 
       val objectList1 = listOf<NameValue>(
            NameValue(iD = "a", value = "1", ),
            NameValue(iD = "b", value = "2", ),
            NameValue(iD = "a", value = "3", ),
            )
        feature_Examples_glue_object.Given_list_of_numbers(objectList1)
 
       val stringListList2 = listOf<List<String>>(
           listOf<String>("a",),)
        feature_Examples_glue_object.When_filtered_by_ID_value(stringListList2)

        val stringListList3 = listOf<List<String>>(
           listOf<String>("4",),)
        feature_Examples_glue_object.Then_sum_is(stringListList3)
        }

    @Test
    fun test_Scenario_Temperature(){
        val feature_Examples_glue_object = Feature_Examples_glue()

        val objectList1 = listOf<TemperatureComparison>(
            TemperatureComparison(f = "32", c = "0", notes = "Freezing", ),
            TemperatureComparison(f = "212", c = "100", notes = "Boiling",),
            TemperatureComparison(f = "-40", c = "-40", notes = "Below zero",),
            )
        feature_Examples_glue_object.Star_Convert_F_to_C(objectList1)
        }
    }


/////////  Data Classes (in .tmpl file) 
package gherkinexecutor.Feature_Examples
data class NameValue( val iD: String = "", val value: String = "0",) {
    fun toNameValueInternal() : NameValueInternal{
        return NameValueInternal( iD.toString(), value.toInt(), ) 
    }
}

// This class has attributes with internal data types 
data class NameValueInternal(
    val iD: String= "".toString(),
    val value: Int= "0".toInt(),) {
    fun toNameValue() : NameValue{
        return NameValue(iD.toString(), value.toString(),)
    }
}

data class TemperatureComparison(
    val f: String = "0", val c: String = "0", val notes: String = "",) {
    fun toTemperatureComparisonInternal() : TemperatureComparisonInternal{
        return TemperatureComparisonInternal(f.toInt(), c.toInt(), notes.toString(), ) 
    }
}
// This class has attribute with internal data types 
data class TemperatureComparisonInternal(
    val f: Int= "0".toInt(),
    val c: Int= "0".toInt(),
    val notes: String= "".toString(),)  {
    fun toTemperatureComparison() : TemperatureComparison{
        return TemperatureComparison(f.toString(), c.toString(), notes.toString(),) 
    }
}

package gherkinexecutor.Feature_Examples

import gherkinexecutor.Feature_Examples.TemperatureCalculations
import kotlin.test.assertEquals

class Feature_Examples_glue {

    val solution = SolutionForListOfNumber()

    fun Given_list_of_numbers(value: List<NameValue>) {
        for (element in value) {
            solution.add(element.toNameValueInternal())
        }
    }

    fun When_filtered_by_ID_value( value : List<List<String>>) {
            solution.setFilterValue((value[0][0]))
    }

    fun Then_sum_is(value: List<List<String>>) {
        val sum = solution.sum()
        assertEquals(value[0][0].toInt(), sum)
    }

    fun Star_Convert_F_to_C(value: List<TemperatureComparison>) {
        for (element in value) {
            // convert the strings to internal data types 
            val temp = element.toTemperatureComparisonInternal()
            assertEquals(
                temp.c,
                TemperatureCalculations.convertFarenheitToCelsius(temp.f),
                temp.notes)
        }
    }
}

//  OK, you actually have to write something !! 

package gherkinexecutor.Feature_Examples

class TemperatureCalculations {
    // makes this a "static" method 
    companion object {
        fun convertFarenheitToCelsius(input: Int): Int {
            return ((input - 32) * 5) / 9
        }
    }
}


class SolutionForListOfNumber {
    private var values = mutableListOf<NameValueInternal>()
    private var filterValue = ""
    fun add(value: NameValueInternal) {
        values.add(value)
    }

    fun setFilterValue(value: String) {
        filterValue = value
    }

    fun sum(): Int {
        var sum = 0
        for (element in values) {
            if (element.iD == filterValue)
                sum += (element.value)
        }
        return sum
    }
}



